#!/usr/bin/python3

# sprk v 1.9.4
# Â©2021 barcek
# License: MIT
# @ github.com
# /barcek/sprk


# imports
# for general use

from pathlib import Path
import sys
from functools import reduce
import os

# for tool features

from datetime import datetime
from itertools import count
import shutil

# for verification

from typing import cast, Union, Callable, Any
from tempfile import NamedTemporaryFile, TemporaryDirectory


# base constants

CURRENT_DIR = Path.cwd()
SPRKFILENAME = "Sprkfile"

PATH_TO_SELF = Path(sys.argv[0]).resolve()
PATH_TO_SPRKFILE = CURRENT_DIR / SPRKFILENAME

TOOLS: dict = {}
TEST_VALUES: dict = {}


# utility functions

def pipe(*fns: Callable) -> Callable:
    """
    Returns a function invoking 'fns' in sequence left to right, the first
    with the initial arguments, each thereafter with the last return value.
    >>> pipe(lambda x, y, z: x + y + z, lambda x: x + 1)(1, 2, 3)
    7
    """
    return lambda *value: reduce(
        lambda acc, fn: fn(acc),
        fns[1:] if len(fns) > 1 else [],
        fns[0](*value)
    )


# template class (Template)

class Template():

    def __init__(self, pars: dict) -> None:
        self.name = self.tool.name_element("item") if "name" not in pars else pars["name"] # type: ignore[attr-defined]
        self.core = ["parts"] if "core" not in pars else pars["core"]
        self.form = {
            "parts": [] if "parts" not in pars else pars["parts"],
            "calls": [] if "calls" not in pars else pars["calls"]
        } if "form" not in pars else pars["form"]


# resource classes (Resource, Process & Option)

class Resource():

    def __init__(self, pars: dict) -> None:
        self.tool = None if "tool" not in pars else pars["tool"]
        self.info = None if "info" not in pars else pars["info"]


class Process(Resource):

    def __init__(self, pars: dict) -> None:
        super(Process, self).__init__(pars)
        self.pool = None if "pool" not in pars else pars["pool"]
        self.rank = 1 if "rank" not in pars else pars["rank"]
        self.call = None if "call" not in pars else pars["call"]
        self.items = [] if "items" not in pars else pars["items"]


class Option(Process):

    def __init__(self, pars: dict) -> None:
        super(Option, self).__init__(pars)
        self.desc = "" if "desc" not in pars else pars["desc"]
        self.word = "" if "word" not in pars else pars["word"]
        self.char = "" if "char" not in pars else pars["char"]
        self.args = [] if "args" not in pars else pars["args"]
        self.info = (
            lambda self, offset:\
                f"{' -' + self.char if self.char else ' '}"\
                f"{', ' if self.char and self.word else ''}"\
                f"{'--' + self.word if self.word else ''}"\
                f"{' ' + ' '.join(self.args if self.args else '')}"\
                f"{offset + self.desc if self.desc else ''}"\
        )(self, "{ALIGN}")


# tool classes (Builder, Composer, Runner & Sprker)

class Builder():

    def __init__(self, pars: dict) -> None:
        self.show = "err" if "show" not in pars else pars["show"]
        self.vars = {
            "delims": {"opening": "{", "divider": ":", "closing": "}"},
            "values": {
                "state": {"string": "STATE", "source": "state"},
                "utils": {"string": "UTILS", "source": "utils"}
            }
        }
        self.state = {
            "name": "project" if "name" not in pars else pars["name"],
            "root": CURRENT_DIR if "root" not in pars else Path(pars["root"]),
            "code": CURRENT_DIR if "code" not in pars else Path(pars["code"]),
            "main": None if "main" not in pars else Path(pars["main"]),
            "nums": {}
        }
        self.utils = {
            "date": str(datetime.now().strftime("%d %B %Y")),
            "time": str(datetime.now().strftime("%H:%M:%S")),
            "zone": str(datetime.now().astimezone().strftime("%z"))
        }
        self._test = {} if "_test" not in pars else pars["_test"]
        self.batches = [] if "batches" not in pars else pars["batches"]

    class Batch():

        def __init__(self, pars: dict) -> None:
            self.dir = CURRENT_DIR if "dir" not in pars else pars["dir"]
            self.items = [] if "items" not in pars else pars["items"]

    def show_messages(self, messages: list, level: str = "inf") -> None:
        """
        Prints messages if level is equal to or lower than the show attribute.
        >>> S.show_messages(['t_str'])
        t_str
        """
        if self.show == "off" or (self.show == "err" and level == "inf"):
            return
        for message in messages:
            print(message)

    def update_state(self, new_state: dict = {}) -> None:
        """
        Updates the state attribute with any new state.
        >>> S.update_state({"t_key": "t_value"}) == None\
                and S.state['t_key'] == 't_value'
        True
        """
        self.state = {**self.state, **new_state}

    def name_element(self, type: str = "item") -> str:
        """
        Returns a name using a type string and generated sequential number.
        >>> S.name_element("t_str") # doctest: +ELLIPSIS
        'new_t_str_...'
        """
        if type not in self.state["nums"]:
            self.state["nums"][type] = count(start=1, step=1)
        return f'new_{type}_{next(self.state["nums"][type])}'

    def read_file(self, filename: Union[str, Path]) -> str:
        """
        Returns any content read from a file for a given filename.
        >>> with NamedTemporaryFile() as f:
        ...     f.write(b"t_str") and f.flush()
        ...     S.read_file(f.name)
        't_str'
        """
        content = None
        try:
            with open(filename, 'rb') as f:
                content = f.read().decode()
        except Exception as err:
            self.show_messages([f"Error: content not read from file '{filename}'. {err}"], "err")
        return "" if content is None else content

    def write_file(self, path: Union[str, Path] = None, content: str = "",
            flag: str = "a", messages: dict = None) -> None:
        """
        Writes any content to a file, calling to create any filename needed.
        >>> with NamedTemporaryFile() as f:
        ...     S.write_file(f.name, "t_str", "w",\
                    {"success": "Wrote test string", "failure": ""})
        ...     f.read().decode()
        Wrote test string
        't_str'
        """
        path = path or self.name_element("file")
        messages = messages or {
            "success": f"{'Wrote' if flag == 'w' else 'Added'}"
                f" {len(content)} characters to file {path}",
            "failure": f"Error: content may not have been written to file '{path}':"
                f"\nContent:\n{content}"
        }
        try:
            with open(path, flag) as f:
                f.write(content)
            self.show_messages([messages["success"]])
        except Exception as err:
            self.show_messages([messages["failure"]], "err")
            print(err)

    def build_identifier(self, value: dict, delims: dict) -> dict:
        """
        Returns an object of substrings for all or part of an identifier.
        >>> S.build_identifier(S._test["t_vars"]["values"]["test"],\
                S._test["t_vars"]["delims"]) == S._test["t_identifier"]
        True
        """
        opening, divider, closing = delims.values()
        return {
            "head": opening + value["string"],
            "neck": delims["divider"],
            "body": "",
            "tail": closing,
            "base": opening + value["string"] + closing
        }

    def identify_variable(self, content: str, identifier: dict) -> Union[dict, None]:
        """
        Seeks an identifier and returns None or the identifier updated.
        >>> S.identify_variable("t_substr ${TEST:t_key}",\
                S._test["t_identifier"]) == S._test["t_identity"]
        True
        """
        start = content.find(identifier["head"])
        if start == -1:
            return None
        end = start + content[start:].find(identifier["tail"])
        gap = content[start + len(identifier["head"]):end]
        if gap and gap.find(identifier["neck"]) != -1:
            identifier["body"] = gap.replace(identifier["neck"], "")
        else:
            identifier["neck"] = ""
        return identifier

    def replace_identifier(self, content: str, name: str, value: dict, identity: dict) -> str:
        """
        Returns content with an identifier replaced by a sourced string.
        >>> S.replace_identifier("t_substr {TEST:t_key}", "t_name",\
                S._test["t_vars"]["values"]["test"], S._test["t_identity"])
        't_substr t_value'
        """
        head, neck, body, tail, base = identity.values()
        source = "" if "source" not in value else value["source"]
        string = None
        notice = f"<!-- NO USEABLE SOURCE FOR '{value['string']}{neck}{body}' -->"
        error = f"Error: identifier location in '{name}' marked '{notice}'."
        if not body and isinstance(source, str):
            string = source
        elif not body and callable(source):
            string = source(self, content, name)
        elif body and hasattr(self, source) and body in getattr(self, source):
            if isinstance(getattr(self, source)[body], str):
                string = str(getattr(self, source)[body])
            elif callable(getattr(self, source)[body]):
               string = getattr(self, source)[body](self, content, name)
        if string is None:
            string = notice
            print(error)
        return content.replace(head + neck + body + tail, string)

    def handle_variables(self, content: str, name: str, values: dict, delims: dict) -> str:
        """
        Returns content with any variables present identified and replaced.
        >>> S.handle_variables("t_substr {TEST:t_key}", "t_name",\
                S._test["t_vars"]["values"], S._test["t_vars"]["delims"])
        't_substr t_value'
        """
        for key in list(values.keys()):
            value = values[key]
            while True:
                identifier = self.build_identifier(value, delims)
                identity = self.identify_variable(content, identifier)
                if identity is None:
                    break
                content = self.replace_identifier(content, name, value, identity)
        return content

    @staticmethod
    def indent_content(string: str = "", spaces: int = 4) -> str:
        """
        Returns a string with a number of spaces added after each newline.
        >>> S.indent_content("t_line_1\\nt_line_2", 2)
        't_line_1\\n  t_line_2'
        """
        return string.replace("\n", "\n" + " " * spaces)

    def insert_content(self, current: str, content: str, anchor: dict = None,
            delims: dict = {"opening": "", "closing": ""}, indent: int = 0, **kargs) -> str:
        """
        Returns content with additional lines combined, indented and inserted.
        >>> S.insert_content("t_substr_1\\n    t_substr_2",\
                "t_substr_3\\nt_substr_4", {"string": "t_substr_1"},\
                {"opening": "\\n", "closing": ""}, 4)
        't_substr_1\\n    t_substr_3\\n    t_substr_4\\n    t_substr_2'
        """
        content = self.indent_content(delims["opening"] + content, indent)
        if anchor == None:
            return current + content + delims["closing"]
        if anchor is not None and "string" in anchor:
            start, length = current.find(anchor["string"]), len(anchor["string"])
            if start == -1:
                return current
        if anchor is not None and "index" in anchor:
            start, length = anchor["index"], 0
            if start >= len(current):
                return current
        return current[:start + length] + content + delims["closing"]\
             + current[start + length:]

    def create_file(self, dir: Path = CURRENT_DIR, filename: str = "",
            content: str = "", input: dict = {"flag": "a"}) -> bool:
        """
        Creates a file if not present, then calls to modify and write any text.
        >>> with NamedTemporaryFile() as f: # doctest: +ELLIPSIS
        ...     S.create_file(Path(""), f.name, "t_str", {"flag": "w"})
        Created file ...
        Wrote 5 characters to file ...
        True
        """
        name = filename or self.name_element("file")
        path, newline = dir / name, "\n"
        if path not in dir.iterdir():
            try:
                path.touch()
                self.show_messages([f"Created file {path}"])
            except Exception as err:
                self.show_messages([
                    f"Error: file '{name}' may not have been created"
                    f"{' with content:' if content else '.'}"
                    f"{newline if content else ''}{content if content else ''}"
                , err], "err")
                return False
        if content:
            if input["flag"] == "i":
                current = self.read_file(filename)
                current = self.insert_content(current, content, **input)
                content = current
                input["flag"] = "w"
            content = self.handle_variables(content, name,
                cast(dict, self.vars["values"]), cast(dict, self.vars["delims"]))
            self.write_file(path, content, input["flag"])
        return True

    def create_folder(self, dir: Path = CURRENT_DIR,
            dirname: str = None, items: list = None) -> bool:
        """
        Creates a folder if not present, then calls to build any items.
        >>> with TemporaryDirectory() as d: # doctest: +ELLIPSIS
        ...     S.create_folder(Path(d), "t_dir")
        ...     "t_dir" in os.listdir(d)
        Created folder ...
        True
        True
        """
        name = dirname or self.name_element("folder")
        path = dir / name
        try:
            path.mkdir()
            self.show_messages([f"Created folder {path}/"])
        except FileExistsError:
            self.show_messages([f"Found existing folder {path}/"], "err")
            pass
        except Exception as err:
            self.show_messages([f"Error: folder '{name}' may not have been created. {err}"], "err")
            return False
        if items:
            self.create_items(items, path)
        return True

    def create_items(self, items: list = [], dir: Path = CURRENT_DIR) -> None:
        """
        Builds a file and folder structure, making any call first per item.
        >>> with TemporaryDirectory() as d: # doctest: +ELLIPSIS
        ...     S.create_items(S._test["t_items"], Path(d))
        ...     "t_file" in os.listdir(Path(d) / "t_dir")
        Created folder ...
        Created file ...
        True
        """
        for item in items:
            if "call" in item:
                item["call"](dir)
            if "filename" in item:
                self.create_file(
                    dir, item["filename"],
                    "" if "content" not in item else item["content"],
                    {"flag": "a"} if "input" not in item else item["input"]
                )
            elif "dirname" in item:
                self.create_folder(
                    dir, item["dirname"],
                    None if "items" not in item else item["items"] or None
                )

    def queue_items(self, dir: Path = CURRENT_DIR, items: list = []) -> None:
        """
        Combines and queues as a batch a directory and a set of items.
        >>> S.queue_items("t_dir", ["t_str"]) == None\
                and S.batches[-1].dir == 't_dir' and S.batches[-1].items == ['t_str']
        True
        """
        self.batches.append(self.Batch({
            "dir": dir,
            "items": items
        }))

    def build_batches(self) -> None:
        """
        Splits each batch in the batches attribute and calls to build.
        >>> with TemporaryDirectory() as d: # doctest: +ELLIPSIS
        ...     S.batches.append(S.Batch({"dir": Path(d),"items": S._test["t_items"]}))
        ...     S.build_batches()
        ...     "t_file" in os.listdir(Path(d) / "t_dir")
        Building batches...
        Created folder ...
        Created file ...
        True
        """
        if self.batches:
            self.show_messages(["Building batches..."])
        for batch in self.batches:
            self.create_items(batch.items, batch.dir)


class Composer(Builder):

    def __init__(self, pars: dict) -> None:
        super(Composer, self).__init__(pars)
        self.templates: dict = {}
        self.items: list = []

    def insert_templates(self, templates: list) -> None:
        """
        Adds self to each template, then adds each to the templates attribute.
        >>> S.insert_templates([Template({"name": "t_name"})]) == None\
                and S.templates["t_name"].tool == S
        True
        """
        for template in templates:
            template.tool = self
            self.templates.update({template.name: template})

    def modify_template(self, name: str, content: dict = {}) -> None:
        """
        Appends elements to a list or dict in a template form attribute.
        >>> S.templates.update({"t_name": S._test["t_template"]}) == None\
                and S.modify_template("t_name", {"t_list_1": ["t_item_2"]}) == None\
                and S.templates["t_name"].form["t_list_1"].pop() == "t_item_2"
        True
        """
        template = self.templates[name]
        for key in content:
            if key == "core":
                template.core.extend(content[key])
            elif key not in template.form:
                template.form[key] = content[key]
            elif key in template.form and isinstance(template.form[key], list):
                template.form[key].extend(content[key])
            elif key in template.form and isinstance(template.form[key], dict):
                template.form[key].update(content[key])

    def queue_modified(self) -> list:
        """
        Returns each template in which a key listed as core has 1+ entries.
        >>> S.templates.update({"t_name": S._test["t_template"]}) == None\
                and S.queue_modified() == [S._test["t_template"]]
        True
        """
        templates = []
        for name in self.templates:
            for item in self.templates[name].core:
                if self.templates[name].form[item]:
                    templates.append(self.templates[name])
                    break
        return templates

    def compose_items(self) -> None:
        """
        Prepares items based on templates, then for each makes any calls.
        >>> S.templates.update({"t_name": S._test["t_template"]}) == None\
                and S.compose_items()
        Composing items...
        t_str
        """
        self.items = self.queue_modified()
        if self.items:
            self.show_messages(["Composing items..."])
        for item in self.items:
            for call in item.form["calls"]:
                call(item)


class Runner(Composer):

    def __init__(self, pars):
        super(Runner, self).__init__(pars)
        self.vars["values"] = {**self.vars["values"], **{
            "align": {
                "string": "ALIGN",
                "source": lambda tool, content, name: None if f"{name}_offsets" not in tool.state
                    else tool.stringify_offset(tool.state[f"{name}_offsets"].pop(0))
            },
            "sprkv": {"string": "SPRKV", "source": lambda\
                tool, content, name: Runner.get_version(tool)},
            "blank": {"string": "BLANK", "source": lambda tool, content, name: ""},
            "using": {"string": "USING", "source": lambda tool, content, name: tool.state["tool"]}
        }}
        self.state = {**self.state, **{
            "caps": [
                {"name": "show_help", "poss": 1}
            ] if "caps" not in pars else [
                {"name": "show_help", "poss": 1}, *pars["caps"]
            ]
        }}
        self.resources = []
        self.pools = {}
        self.lead = [] if "lead" not in pars else pars["lead"]
        self.work = {
            "prep": [] if "prep" not in pars else pars["prep"],
            "wait": [] if "wait" not in pars else pars["wait"],
            "tidy": [] if "tidy" not in pars else pars["tidy"]
        }

    class Task():

        def __init__(self, pars):
            self.process = Option({}) if "process" not in pars else pars["process"]
            self.args = [] if "args" not in pars else pars["args"]

    def provide_resources(self, resources: list) -> None:
        """
        Adds self to each resource instance, then each to the resources attribute.
        >>> (S.provide_resources(S._test["t_resources"]) == None)\
                and S.resources == S._test["t_resources"]\
                and S.resources.pop().tool == S and S.resources.pop().tool == S
        True
        """
        for resource in resources:
            resource.tool = self
            self.resources.append(resource)

    @staticmethod
    def getattrs(host: Any, objects: str, key: str) -> list:
        """
        Returns the value corresponding to a key for each object in a list.
        >>> S.getattrs(S._test["t_object"], "t_attr_list", "t_attr_int")
        [1, 2]
        """
        return [getattr(object, key) for object in getattr(host, objects)\
            if len(getattr(host, objects)) > 1 and getattr(object, key) is not None]

    @staticmethod
    def get_offsets(lines: list, spaces: int = 1, align_id: str = "{ALIGN}") -> list:
        """
        Returns a list of the offsets required to align a set of strings.
        >>> S.get_offsets(["l{ALIGN}r", "long_l{ALIGN}r"], 2)
        [7, 2]
        """
        lengths = [len(line[:line.find(align_id)]) for line in lines
            if line.find(align_id) != -1]
        offsets = list(map(lambda length: (max(lengths) - length + spaces),
            lengths))
        return offsets

    @staticmethod
    def stringify_offset(offset: int) -> str:
        """
        Returns a string composed of a number of spaces equal to offset.
        >>> S.stringify_offset(7)
        '       '
        """
        return " " * offset

    @staticmethod
    def show_help(resource, pars: list = []) -> None:
        """
        Builds a help page using any resource instance info attributes.
        >>> (S.resources.extend(S._test["t_resources"]) == None)\
                and Runner.show_help(Option({"tool": S})) and S.resources.clear()
         -d, --do    do sth
         -e, --else  do sth else
        """
        infos = [info for info in resource.tool.getattrs(resource.tool, "resources",
            "info") if info is not None]
        resource.tool.state["help_offsets"] = resource.tool.get_offsets(infos)
        for info in infos:
            info = resource.tool.handle_variables(info, "help",
                resource.tool.vars["values"], resource.tool.vars["delims"])
            if info is not None:
                print(info)

    @staticmethod
    def get_version(tool) -> str:
        """
        Returns the substring from line 3 containing name and version number.
        >>> S.get_version(S) # doctest: +ELLIPSIS
        'sprk v...'
        """
        return tool.read_file(PATH_TO_SELF)[22:34]

    @staticmethod
    def show_version(resource, pars: list = []) -> None:
        """
        Prints the substring from line 3 containing name and version number.
        >>> S.show_version(Option({"tool": S})) # doctest: +ELLIPSIS
        Source code: sprk v...
        """
        print(f"Source code: {resource.tool.get_version(resource.tool)}")

    def request_call(self, call: str) -> bool:
        """
        Returns True if a call can be made, adding a use if capped, else False.
        >>> (S.state["caps"].extend(S._test["t_caps"]) == None)\
                and S.request_call("t_fn") and S.request_call("t_fn")\
                and (S.request_call("t_fn") == False) and S.state["caps"].pop()
        {'name': 't_fn', 'poss': 2, 'used': 2}
        """
        for entry in self.state["caps"]:
            if not "used" in entry:
                entry["used"] = 0
            if entry["name"] == call and entry["used"] < entry["poss"]:
                entry["used"] += 1
            elif entry["name"] == call and entry["used"] >= entry["poss"]:
                return False
        return True

    def match_flag(self, flag):
        """Returns the option instance matching a flag, else a new to show help."""
        for resource in self.resources:
            if (hasattr(resource, "word") and flag == resource.word)\
                or (hasattr(resource, "char") and flag == resource.char):
                if (resource.call is not None and self.request_call(resource.call.__name__))\
                    or resource.items:
                    return resource
                else:
                    return Option({ "tool": self, "call": lambda self, pars: {} })
        else:
            self.show_messages([f"Note: '{'--' if len(flag) > 1 else '-'}{flag}' is not a flag."])
            return Option({
                "tool": self,
                "call": self.show_help if self.request_call("show_help")\
                    else lambda self, pars: {}
            })

    def record_pooled(self, options):
        """Records pools to which option instances belong, each with an instance count."""
        for option in options:
            if hasattr(option.process, "pool") and option.process.pool in self.pools:
                self.pools[option.process.pool] += 1
            elif hasattr(option.process, "pool"):
                self.pools[option.process.pool] = 1

    def queue_options(self, strings):
        """Returns a task instance per flag with any arguments, then calls to record pools."""
        options = []
        for string in strings:
            if string[0] ==  "-" and string[1] != "-":
                for char in string[1:]:
                    options.append(self.Task({
                        "process": self.match_flag(char),
                        "args": []
                    }))
            elif string[0] == "-" and string[1] == "-":
                options.append(self.Task({
                    "process": self.match_flag(string[2:]),
                    "args": []
                }))
            elif options:
                options[-1].args.append(string)
        self.record_pooled(options)
        return options

    def queue_processes(self):
        """Returns a task for each process unpooled or pooled with 1+ options."""
        return [
            self.Task({"process": resource}) for resource in self.resources
            if isinstance(resource, Process) and not isinstance(resource, Option)
                and (not hasattr(resource, "pool") or (hasattr(resource, "pool")
                and resource.pool in self.pools and self.pools[resource.pool] > 0))
        ]

    def order_tasks_by_pool(self, tasks):
        """Returns all tasks with lead pools prioritised in lead attribute order."""
        for entry in self.lead[::-1]:
            for task in tasks:
                if hasattr(task.process, "pool") and task.process.pool == entry:
                    tasks.remove(task)
                    tasks.insert(0, task)
        return tasks

    def order_tasks_by_rank(self, tasks):
        """Returns all tasks with the tasks in each pool in ascending rank order."""
        for pool in self.pools:
            i = 0
            indices = [tasks.index(task) for task in tasks if task.process.pool == pool]
            pooled_tasks = list(filter(lambda task: task.process.pool == pool, tasks))
            pooled_tasks.sort(key=lambda task: task.process.rank)
            for index in indices:
                tasks.pop(index)
                tasks.insert(index, pooled_tasks[i])
                i += 1
        return tasks

    def apply_ordered_tasks(self, tasks):
        """For each task makes any call, else queues any items."""
        for task in tasks:
            if task.process.call is not None:
                new_state = task.process.call(task.process, task.args) or {}
            elif task.process.items:
                new_state = self.queue_items(self.state["root"],
                    task.process.items) or {}
            if "new_state" in dir() and new_state.keys():
                self.update_state(new_state)

    def run_tasks(self, argv):
        """Calls to queue tasks, then calls to order by pool and rank and run."""
        tasks = self.queue_options(argv) + self.queue_processes()
        if tasks:
            self.show_messages(["Running tasks..."])
            pipe(
                self.order_tasks_by_pool,
                self.order_tasks_by_rank,
                self.apply_ordered_tasks
            )(tasks)

    def do_work(self, type):
        """Calls each function listed for the given type in the work attribute."""
        if self.work[type]:
            for call in self.work[type]:
                call(self)

    def use(self, tool, argv):
        """Sets tool and calls for any prep, then each stage, then any tidying."""
        self.update_state({
            "tool": tool
        })
        self.do_work("prep")
        self.run_tasks(argv)
        self.compose_items()
        self.build_batches()
        self.do_work("wait")
        self.do_work("tidy")


class Sprker(Runner):

    def __init__(self, pars):
        super(Sprker, self).__init__(pars)

    @staticmethod
    def switch(resource, pars=[]):
        """Prints all items in the TOOLS dictionary or replaces the active tool."""
        old = resource.tool.state["tool"]
        if not pars:
            resource.tool.show_messages([f"Active tool: {old}. Available: {'; '.join(TOOLS.keys())}."])
            return {}
        new = pars[0]
        if new not in TOOLS.keys():
            resource.tool.show_messages([f"Tool '{new}' does not exist."])
            return {}
        content = resource.tool.read_file(PATH_TO_SELF)
        content = content.replace(f'ACTIVE_TOOL = TOOLS["{old}"]', f'ACTIVE_TOOL = TOOLS["{new}"]')
        messages = {
            "success": f"Switched from {old} to {new}.",
            "failure": f"May not have switched from {old} to {new}."
        }
        resource.tool.write_file(PATH_TO_SELF, content, "w", messages)
        TOOLS[new].update_state({"tool": new})
        resource.tool.show_help(Option({"tool": TOOLS[new]}))

    @staticmethod
    def update(resource, pars=[]):
        """Attempts to copy a sprkfile over the sprk source file."""
        src = PATH_TO_SPRKFILE
        if pars and os.path.isfile(pars[0])\
            and os.path.basename(pars[0]) == SPRKFILENAME:
            src = pars[0]
        elif pars and os.path.isdir(pars[0])\
            and SPRKFILENAME in os.listdir(pars[0]):
            src = Path(pars[0]) / SPRKFILENAME
        elif pars:
            resource.tool.show_messages([f"Note: '{SPRKFILENAME}' not found at {pars[0]}."])
            return {}
        try:
            shutil.copy(src, PATH_TO_SELF)
            resource.tool.show_messages(["Updated sprk."])
        except Exception as err:
            resource.tool.show_messages([f"May not have updated sprk. {err}"], "err")

    @staticmethod
    def backup(resource, pars=[]):
        """Attempts to copy the sprk source file to another location."""
        dest = PATH_TO_SPRKFILE
        if pars and os.path.basename(pars[0]) == SPRKFILENAME:
            dest = pars[0]
        elif pars and os.path.isdir(pars[0]):
            dest = Path(pars[0]) / SPRKFILENAME
        elif pars:
            resource.tool.show_messages([f"{SPRKFILENAME} not copied: {pars[0]} not a valid argument for DIR."])
            return {}
        try:
            shutil.copy(PATH_TO_SELF, dest)
            resource.tool.show_messages([f"Copied sprk to {dest}"])
        except Exception as err:
            resource.tool.show_messages([f"May not have copied sprk to {dest}. {err}"], "err")


# verification of docstring interactive examples - optional:
# uncomment last line of file to do so with each use of sprk

def run_docstring_interactive_examples(is_verbose=False):
    "Runs examples with a test Sprker instance and non-verbose by default."

    class TestClass():

        def __init__(self, pars):
            self.t_attr_int = 0 if "int" not in pars else pars["int"]
            self.t_attr_list = [] if "items" not in pars else pars["items"]

    TEST_VALUES = {
        "t_vars": {"delims": {"opening": "{", "divider": ":", "closing": "}"}, "values": {"test": {"string": "TEST", "source": "_test"}},},
        "t_identifier": {"head": "{TEST", "neck": ":", "body": "", "tail": "}", "base": "{TEST}"},
        "t_identity": {"head": "{TEST", "neck": ":", "body": "t_key", "tail": "}", "base": "{TEST}"},
        "t_key": "t_value",
        "t_items": [{"dirname": "t_dir", "items": [{"filename": "t_file"}]}],
        "t_template": Template({"name": "t_name", "core": ["t_list_1", "t_list_2"], "form": {"t_list_1": ["t_item_1"], "t_list_2": ["t_item_1"], "calls": [lambda tool: print("t_str")]}}),
        "t_object": TestClass({"items": [TestClass({"int": 1}), TestClass({"int": 2})]}),
        "t_resources": [Option({"desc": "do sth", "word": "do", "char": "d"}), Option({"desc": "do sth else", "word": "else", "char": "e"})],
        "t_caps": [{"name": "t_fn", "poss": 2}]
    }

    import doctest

    print('Running docstring interactive examples...')
    doctest.testmod(extraglobs={"S": Sprker({"_test": TEST_VALUES, "show": "all"})}, verbose=is_verbose)


# resource instances

BLANK = Resource({"info": "{BLANK}"})
SPRKV = Resource({"info": "{SPRKV}"})
USAGE = Resource({"info": "Usage: sprk [--option/-o [ARG ...] ...]"})
USING = Resource({"info": "Using: {USING}"})

SWITCH = {
    "desc": f"switch to TOOL or show tools currently available",
    "word": "switch",
    "char": "S",
    "call": Sprker.switch,
    "args": ["[TOOL]"]
}
BACKUP = {
    "desc": f"save sprk as/over a {SPRKFILENAME} here or in any DIR",
    "word": "backup",
    "char": "B",
    "call": Sprker.backup,
    "args": ["[DIR]"]
}
UPDATE = {
    "desc": f"replace sprk from a {SPRKFILENAME} here or in any DIR",
    "word": "update",
    "char": "U",
    "call": Sprker.update,
    "args": ["[DIR]"]
}
VERSION = {
    "desc": "show the current version number",
    "word": "version",
    "char": "V",
    "call": Runner.show_version
}
HELP = {
    "desc": "show the help page",
    "word": "help",
    "char": "h",
    "call": Runner.show_help
}


# TOOL: 'combined'

import webbrowser
from http.server import HTTPServer, SimpleHTTPRequestHandler


# 'combined' template functions, receiving template instance as 'template'

def create_ignores(template):
    """Prepares each file in the ignores template and calls to queue all as a batch."""
    items = []
    for file in template.form["files"]:
        entries = []
        for type in list(filter(
            lambda key: key != "files" and key != "calls",
            template.form.keys()
        )):
            if type in file["list"]:
                entries.extend(template.form[type])
        items.append({
            "filename": file["name"],
            "content": "\n".join(list(dict.fromkeys(entries)))
        })
    template.tool.queue_items(template.tool.state["root"], items)


# 'combined' resource constants,
# e.g. strings & lists of dictionaries for resource 'items' attribute

README_MD = """\
# {STATE:name}

Created: {UTILS:date}"""

ROOT_ITEMS = {

    "readme": [
        {
            "filename": "README.md",
            "content": README_MD
        }
    ],
    "license": [
        {
            "filename": "LICENSE.txt"
        }
    ]
}

INDEX_HTML = """\
<!DOCTYPE html>
<html lang=\"en\">
    <head>
        <meta charset=\"utf-8\"/>
        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"/>
        <title>{STATE:name}</title>
    </head>
    <body>
        <h1>{STATE:name}</h1>
    </body>
</html>"""

WEB_ASSETS = {

    "public": [
        {
            "dirname": "public",
            "items": [
                {
                    "filename": "index.html",
                    "content": INDEX_HTML
                }
            ]
        }
    ]
}


# 'combined' resource functions,
# receiving resource instance as 'resource' & any arguments as 'pars',
# optionally returning a dictionary with any state changes

def start_project(resource, pars=[]):
    """Attempts to create a project folder and updates name and paths in state."""
    name = pars[0] if pars else resource.tool.state["name"]
    path = CURRENT_DIR / name
    if path in CURRENT_DIR.iterdir():
        response = input(
            f"Folder '{name}' already exists. By continuing, files in the "
            f"existing '{name}' may be overwritten or otherwise modified.\n"
            "Continue? (enter 'y'/'Y' to continue; anything else to stop) "
        )
        if response not in ["y", "Y"]:
            sys.exit()
    root = code = path
    resource.tool.create_folder(dirname=name)
    if resource.tool.state["code"] != resource.tool.state["root"]:
        code = resource.tool.state["code"]
    return {"name": name, "root": root, "code": code}

def initialize_git(resource, pars=[]):
    """Attempts to initialize a Git repo and updates the ignores template."""
    try:
        os.system(f'cd {resource.tool.state["root"]}; git init; cd ..')
    except Exception as err:
        resource.tool.show_messages(["Git repository may not have been initialized. {err}"], "err")
    resource.tool.modify_template("ignores", {
        "nonr": [".git", ".gitignore"],
        "files": [
            {"name": ".gitignore", "list": ["rein", "sens"]}
        ]
    })

def open_browser_tab(resource, url):
    """Attempts to open a new default browser tab displaying a given URL."""
    try:
        webbrowser.open_new_tab(url)
        resource.tool.show_messages([f"Requested a browser tab displaying {url}."])
    except Exception as err:
        resource.tool.show_messages([f"Error: may not have opened a browser tab displaying {url}. {err}"], "err")

def get_file_server(resource, root, host, port):
    """Returns a function to serve files from a given root to a given URL."""

    class StaticHandler(SimpleHTTPRequestHandler):

        def do_GET(self):
            self.directory = root
            return SimpleHTTPRequestHandler.do_GET(self)

    staticHandler = StaticHandler

    def serve_files(tool):
        try:
            with HTTPServer((host, port), staticHandler) as server:
                open_browser_tab(resource, f"{host}:{port}")
                tool.show_messages([f"Starting the server: '{root}' to {host}:{port}."])
                server.serve_forever()
        except KeyboardInterrupt:
            tool.show_messages(["\nServer stopped."])
        except Exception as err:
            tool.show_messages(["Error: may not have started server. {err}"], "err")

    return serve_files

def serve_public_local(resource, pars=[]):
    """Passes arguments to 'get_file_server' and adds to 'wait' work queue."""
    root = pars[0] if pars else str(resource.tool.state["root"] / "public")
    host = "localhost"
    port = int(pars[1]) if len(pars) > 1 else 8080
    serve_public_localhost_8080 = get_file_server(resource, root, host, port)
    resource.tool.work["wait"].append(serve_public_localhost_8080)

def test_source_code(resource, pars=[]):
    run_docstring_interactive_examples(True)


# 'combined' template instances

IGNORES = {
    "name": "ignores",
    "core": ["files"],
    "form": {
        "rein": [],  # item type, reinstalled (str)
        "nonr": [],  # item type, non-runtime (str)
        "sens": [],  # item type, sensitive (str)
        "files": [],  # {"name": filename, "list": [type]}
        "calls": [create_ignores]
    }
}


# 'combined' resource instances

FOLDER = {
    "pool": "project",
    "rank": 1,
    "desc": "create a project folder here, with NAME if given",
    "word": "folder",
    "char": "f",
    "call": start_project,
    "args": ["[NAME]"]
}

GITINIT = {
    "pool": "project",
    "rank": 2,
    "desc": "initialize a Git repo & create a .gitignore file",
    "word": "gitinit",
    "char": "g",
    "call": initialize_git
}

README = {
    "desc": "create a README.md file w/ any NAME as its title",
    "word": "readme",
    "char": "r",
    "items": ROOT_ITEMS["readme"]
}

LICENSE = {
    "desc": "create a blank LICENSE.txt file (cf. '--choose')",
    "word": "license",
    "char": "l",
    "items": ROOT_ITEMS["license"]
}

PUBLIC = {
    "desc": "create a public folder w/ index.html ('--serve')",
    "word": "public",
    "char": "b",
    "items": WEB_ASSETS["public"]
}

CHOOSE = {
    "desc": "open the 'choosealicense.com' list in a new tab",
    "word": "choose",
    "char": "c",
    "call": lambda resource, pars=[]: open_browser_tab(resource, "https://choosealicense.com/licenses")
}

SERVE = {
    "desc": "serve public or DIR contents at localhost ('-b')",
    "word": "serve",
    "char": "v",
    "call": serve_public_local,
    "args": ["[DIR[ PORT]]"]
}

SPRK = {
    "desc": "open the sprk Github repo page in a browser tab",
    "word": "sprk",
    "char": "s",
    "call": lambda resource, pars=[]: open_browser_tab(resource, "https://github.com/barcek/sprk")
}

PYTHON = {
    "desc": "open the Python3 documentation in a browser tab",
    "word": "python",
    "char": "p",
    "call": lambda resource, pars=[]: open_browser_tab(resource, "https://www.python.org/doc/")
}

TEST = {
    "desc": "run the internal docstring interactive examples",
    "word": "test",
    "char": "t",
    "call": test_source_code
}


# 'combined' tool class instantiation, passing configuration dictionary,
# with assignment of instance to key in TOOLS dictionary

TOOLS.update({
    "combined": Sprker({
        "prep": [lambda tool: print("Starting...")],
        "show": "all",  # either "off", "err" (default) or "all"
        "lead": ["project"],  # order of priority for any pools
        "tidy": [lambda tool: print("Finished.")]
    })
})


# 'combined' instance extension, passing template & resource class instantiations

TOOLS["combined"].insert_templates([

    Template(IGNORES)
])

TOOLS["combined"].provide_resources([

    BLANK,
    SPRKV,
    BLANK,
    USAGE,

    BLANK,
    Resource({"info": "Apply any or all of the following options for the action(s) described."}),
    BLANK,

    Option(FOLDER),

    BLANK,
    Resource({"info": "and then inside this folder, or here if not created, do the following:"}),
    BLANK,

    Option(GITINIT),

    BLANK,

    Option(README),
    Option(LICENSE),
    Option(PUBLIC),

    BLANK,
    Resource({"info": "and/or do the following:"}),
    BLANK,

    Option(CHOOSE),
    Option(SERVE),

    BLANK,

    Option(BACKUP),
    Option(UPDATE),

    BLANK,

    Option(SPRK),
    Option(PYTHON),
    Option(TEST),

    BLANK,

    Option(SWITCH),

    BLANK,

    Option(VERSION),
    Option(HELP),

    BLANK,
    Resource({"info": f"and customize the tool: add, modify or remove any option via {SPRKFILENAME}."}),
    BLANK,

    USING,
    BLANK
])


# TOOL: 'creator'

# 'creator' tool class instantiation, passing configuration dictionary,
# & assignment of new instance to own key in TOOLS dictionary

TOOLS.update({
    "creator": Sprker({
        "prep": [lambda tool: print("Starting...")],
        "show": "all",  # either "off", "err" (default) or "all"
        "lead": ["project"],  # order of priority for any pools
        "tidy": [lambda tool: print("Finished.")]
    })
})

# 'creator' instance extension, passing template & resource class instantiations

TOOLS["creator"].insert_templates([

    Template(IGNORES)
])

TOOLS["creator"].provide_resources([

    BLANK,
    SPRKV,
    BLANK,
    USAGE,

    BLANK,
    Resource({"info": "Apply any or all of the following options for the action(s) described."}),
    BLANK,

    Option(FOLDER),

    BLANK,
    Resource({"info": "and then inside this folder, or here if not created, do the following:"}),
    BLANK,

    Option(GITINIT),

    BLANK,

    Option(README),
    Option(LICENSE),
    Option(PUBLIC),

    BLANK,
    Resource({"info": "and/or do the following:"}),
    BLANK,

    Option(CHOOSE),
    Option(SERVE),

    BLANK,

    Option(BACKUP),
    Option(UPDATE),

    BLANK,

    Option(SWITCH),

    BLANK,

    Option(VERSION),
    Option(HELP),

    BLANK,
    Resource({"info": f"and customize the tool: add, modify or remove any option via {SPRKFILENAME}."}),
    BLANK,

    USING,
    BLANK
])


# TOOL: 'adapter'

# 'adapter' tool class instantiation, passing configuration dictionary,
# & assignment of new instance to own key in TOOLS dictionary

TOOLS.update({
    "adapter": Sprker({
        "prep": [lambda tool: print("Starting...")],
        "show": "all",  # either "off", "err" (default) or "all"
        "tidy": [lambda tool: print("Finished.")]
    })
})


# 'adapter' instance extension, passing template & resource class instantiations

TOOLS["adapter"].provide_resources([

    BLANK,
    SPRKV,
    BLANK,
    USAGE,

    BLANK,
    Resource({"info": "Apply any or all of the following options for the action(s) described."}),
    BLANK,

    Option(SPRK),
    Option(PYTHON),
    Option(TEST),

    BLANK,

    Option(BACKUP),
    Option(UPDATE),

    BLANK,

    Option(SWITCH),

    BLANK,

    Option(VERSION),
    Option(HELP),

    BLANK,
    Resource({"info": f"and customize the tool: add, modify or remove any option via {SPRKFILENAME}."}),
    BLANK,

    USING,
    BLANK
])


# declaration & assignment for ACTIVE_TOOL constant

ACTIVE_TOOL = TOOLS["combined"]


# use of ACTIVE_TOOL, passing tool name & relevant arguments

if __name__ == "__main__":

    args = [sys.argv[0]] + (sys.argv[1:] if len(sys.argv) > 1 else ["-h"])

    ACTIVE_TOOL.use(
        [key for key, value in TOOLS.items() if value == ACTIVE_TOOL][0],
        args
    )


# run_docstring_interactive_examples()
