#!/usr/bin/python3

# sprk v 1.2.2
# Â©2021 barcek
# License: MIT
# @ github.com
# /barcek/sprk


import sys
from pathlib import Path
import shutil
from itertools import count
import types
import os


# base constants

CURRENT_DIR = Path.cwd()
SPRKFILENAME = "Sprkfile"

PATH_TO_SELF = Path(sys.argv[0]).resolve()
PATH_TO_SPRKFILE = CURRENT_DIR / SPRKFILENAME

TOOLS = {}


# template class (Template)

class Template():

    def __init__(self, pars):
        self.name = self.tool.name_element("item") if "name" not in pars else pars["name"]
        self.core = ["parts"] if "core" not in pars else pars["core"]
        self.form = {
            "parts": [] if "parts" not in pars else pars["parts"],
            "calls": [] if "calls" not in pars else pars["calls"]
        } if "form" not in pars else pars["form"]


# resource classes (Resource, Process & Option)

class Resource():

    def __init__(self, pars):
        self.tool = None if "tool" not in pars else pars["tool"]
        self.info = None if "info" not in pars else pars["info"]


class Process(Resource):

    def __init__(self, pars):
        super(Process, self).__init__(pars)
        self.pool = None if "pool" not in pars else pars["pool"]
        self.rank = 1 if "rank" not in pars else pars["rank"]
        self.call = None if "call" not in pars else pars["call"]
        self.items = [] if "items" not in pars else pars["items"]


class Option(Process):

    def __init__(self, pars):
        super(Option, self).__init__(pars)
        self.desc = "" if "desc" not in pars else pars["desc"]
        self.word = "" if "word" not in pars else pars["word"]
        self.char = "" if "char" not in pars else pars["char"]
        self.args = [] if "args" not in pars else pars["args"]
        self.info = (
            lambda self, tab:\
                f"{' -' + self.char if self.char else ' '}"\
                f"{', ' if self.char and self.word else ''}"\
                f"{'--' + self.word if self.word else ''}"\
                f"{' ' + ' '.join(self.args if self.args else '')}"\
                f"{tab + self.desc if self.desc else '{EMPTY}'}"\
        )(self, "{ALIGN}")


# tool classes (Builder, Composer, Runner & Sprker)

class Builder():

    def __init__(self, pars):
        self.vars = {
            "delims": {"opening": "{", "divider": ":", "closing": "}"},
            "values": {"state": {"string": "STATE", "source": "state"}}
        }
        self.state = {
            "name": "project" if "name" not in pars else pars["name"],
            "root": CURRENT_DIR if "root" not in pars else Path(pars["root"]),
            "code": CURRENT_DIR if "code" not in pars else Path(pars["code"]),
            "main": None if "main" not in pars else Path(pars["main"]),
            "nums": {}
        }
        self.batches = [] if "batches" not in pars else pars["batches"]

    class Batch():

        def __init__(self, pars):
            self.dir = CURRENT_DIR if "dir" not in pars else pars["dir"]
            self.items = [] if "items" not in pars else pars["items"]

    def update_state(self, new_state={}):
        """Updates the state attribute with any new state."""
        self.state = {**self.state, **new_state}

    def name_element(self, type="item"):
        """Returns a name using a type string and generated sequential number."""
        if type not in self.state["nums"]:
            self.state["nums"][type] = count(start=1, step=1)
        return f'new_{type}_{next(self.state["nums"][type])}'

    @staticmethod
    def read_file(filename):
        """Returns any content read from a file for a given filename."""
        content = None
        try:
            with open(filename, 'r') as f:
                content = f.read()
        except Exception as err:
            print(f"Error: content not read from file '{filename}'.")
            print(err)
        return content

    def write_file(self, path=None, content="", flag="a", messages=None):
        """Writes any content to a file, calling to create any filename needed."""
        path = path or self.name_element("file")
        messages = messages or {
            "success": f"{'Wrote' if flag == 'w' else 'Added'}"
                f" {len(content)} characters to file {path}",
            "failure": f"Error: content may not have been written to file '{path}':"
                f"\nContent:\n{content}"
        }
        try:
            with open(path, flag) as f:
                f.write(content)
            print(messages["success"])
        except Exception as err:
            print(messages["failure"])
            print(err)

    def build_identifier(self, value, delims):
        """Returns an object of substrings for all or part of an identifier."""
        opening, divider, closing = delims.values()
        return {
            "head": opening + value["string"],
            "neck": delims["divider"],
            "body": "",
            "tail": delims["closing"]
        }

    def identify_variable(self, content, identifier):
        """Seeks an identifier and returns either None or adjusted identifier."""
        start = content.find(identifier["head"])
        if start == -1:
            return None
        end = start + content[start:].find(identifier["tail"])
        gap = content[start + len(identifier["head"]):end]
        if gap and gap.find(identifier["neck"]) != -1:
            identifier["body"] = gap.replace(identifier["neck"], "")
        else:
            identifier["neck"] = ""
        return identifier

    def replace_identifier(self, content, name, value, identity):
        """Returns content with one identifier replaced by a related value."""
        head, neck, body, tail = identity.values()
        source = None if "source" not in value else value["source"]
        new = f"<!-- NO USEABLE SOURCE FOR '{value['string']}{neck}{body}' -->"
        err = f"Error: in file '{name}' identifier location marked '{new}'."
        if not body and isinstance(source, str):
            new = source
        elif body and hasattr(self, source) and body in getattr(self, source):
            new = str(getattr(self, source)[body])
        else:
            print(err)
        return content.replace(head + neck + body + tail, new)

    def handle_variables(self, content, name, values, delims):
        """Returns content with any variables present identified and replaced."""
        for key in list(values.keys()):
            value = values[key]
            while True:
                identifier = self.build_identifier(value, delims)
                identity = self.identify_variable(content, identifier)
                if identity is None:
                    break
                content = self.replace_identifier(content, name, value, identity)
        return content

    @staticmethod
    def indent_content(spaces=4, string=""):
        """Returns a string with a number of spaces added after each newline."""
        return string.replace("\n", "\n" + " " * spaces)

    def insert_content(self, current, content, anchor={"index": -1},
            delims={"opening": "", "closing": ""}, indent=0, **kargs):
        """Returns content with additional lines combined, indented and inserted."""
        content = self.indent_content(indent, delims["opening"] + content)
        if "string" in anchor:
            start, length = current.find(anchor["string"]), len(anchor["string"])
            if start == -1:
                return current
        else:
            start, length = anchor["index"], 0
            if start >= len(current):
                return current
        return current[:start + length] + content + delims["closing"]\
             + current[start + length + 1:]

    def create_file(self, dir=CURRENT_DIR, filename=None, content="",
            input={"flag": "a"}):
        """Creates a file if not present, then calls to modify and write any text."""
        name = filename or self.name_element("file")
        path, newline = dir / name, "\n"
        if path not in dir.iterdir():
            try:
                path.touch()
                print(f"Created file {path}")
            except Exception as err:
                print(
                    f"Error: file '{name}' may not have been created"
                    f"{' with content:' if content else '.'}"
                    f"{newline if content else ''}{content if content else ''}"
                )
                print(err)
                return False
        if content:
            if input["flag"] == "i":
                current = self.read_file(filename)
                current = self.insert_content(current, content, **input)
                content = current
                input["flag"] = "w"
            content = self.handle_variables(content, name,
                self.vars["values"], self.vars["delims"])
            self.write_file(path, content, input["flag"])
        return True

    def create_folder(self, dir=CURRENT_DIR, dirname=None, items=None):
        """Creates a folder if not present, then calls to build any items."""
        name = dirname or self.name_element("folder")
        path = dir / name
        try:
            path.mkdir()
            print(f"Created folder {path}/")
        except FileExistsError:
            print(f"Found existing folder {path}/")
            pass
        except Exception as err:
            print(f"Error: folder '{name}' may not have been created.")
            print(err)
            return False
        if items:
            self.create_items(items, path)
        return True

    def create_items(self, items=[], dir=CURRENT_DIR):
        """Builds a file and folder structure, making any call first per item."""
        for item in items:
            if "call" in item:
                item["call"](dir)
            if "filename" in item:
                self.create_file(
                    dir, item["filename"],
                    "" if "content" not in item else item["content"],
                    {"flag": "a"} if "input" not in item else item["input"]
                )
            elif "dirname" in item:
                self.create_folder(
                    dir, item["dirname"],
                    None if "items" not in item else item["items"] or None
                )

    def queue_items(self, dir=CURRENT_DIR, items=[]):
        """Combines and queues as a batch a directory and a set of items."""
        self.batches.append(self.Batch({
            "dir": dir,
            "items": items
        }))

    def build_batches(self):
        """Splits each batch in the batches attribute and calls to build."""
        if self.batches:
            print("Building batches...")
        for batch in self.batches:
            self.create_items(batch.items, batch.dir)


class Composer(Builder):

    def __init__(self, pars):
        super(Composer, self).__init__(pars)
        self.templates = {}
        self.items = []

    def insert_templates(self, templates):
        """Adds self to each template, then adds each to the state attribute."""
        for template in templates:
            template.tool = self
            self.templates.update({template.name: template})

    def modify_template(self, name, content={}):
        """Appends elements to a list or dict in a template form attribute."""
        template = self.templates[name]
        for key in content:
            if key == "core":
                template.core.extend(content[key])
            elif key not in template.form:
                template.form[key] = content[key]
            elif key in template.form and isinstance(template.form[key], list):
                template.form[key].extend(content[key])
            elif key in template.form and isinstance(template.form[key], dict):
                template.form[key].update(content[key])

    @staticmethod
    def dedupe_list(items):
        """Returns a list with any duplicate items removed."""
        return list(dict.fromkeys(items))

    def queue_modified(self):
        """Returns each template in which a key listed as core has 1+ entries."""
        templates = []
        for name in self.templates:
            templates.extend([
                self.templates[name] for item in self.templates[name].core
                if self.templates[name].form[item]
            ])
        return self.dedupe_list(templates)

    def compose_items(self):
        """Prepares items based on templates, then for each makes any calls."""
        self.items = self.queue_modified()
        if self.items:
            print("Composing items...")
        for item in self.items:
            for call in item.form["calls"]:
                call(item)


class Runner(Composer):

    def __init__(self, pars):
        super(Runner, self).__init__(pars)
        self.vars["values"] = {**self.vars["values"], **{
            "align": {"string": "ALIGN"},
            "blank": {"string": "BLANK"},
            "empty": {"string": "EMPTY"},
            "using": {"string": "USING"}
        }}
        self.state = {**self.state, **{
            "caps": [
                {"name": "show_help", "poss": 1, "used": 0}
            ]
        }}
        self.resources = []
        self.tasks = []
        self.pools = {}
        self.lead = [] if "lead" not in pars else pars["lead"]
        self.work = {
            "prep": [] if "prep" not in pars else pars["prep"],
            "tidy": [] if "tidy" not in pars else pars["tidy"]
        }

    class Task():

        def __init__(self, pars):
            self.process = Option({}) if "process" not in pars else pars["process"]
            self.args = [] if "args" not in pars else pars["args"]

    def provide_resources(self, resources):
        """Adds self to each resource instance, then each to the resources attribute."""
        for resource in resources:
            resource.tool = self
            self.resources.append(resource)

    @staticmethod
    def getattrs(host, objects, key):
        """Returns the value corresponding to a given key for each object in a list."""
        return [getattr(object, key) for object in getattr(host, objects)\
            if len(getattr(host, objects)) > 1 and getattr(object, key) is not None]

    @staticmethod
    def get_using():
        """Returns the key corresponding to the active tool in the TOOLS dictionary."""
        return [key for key, value in TOOLS.items() if value == ACTIVE_TOOL][0]

    @staticmethod
    def show_help(self, pars=[]):
        """Builds a help page using any resource instance info attributes."""
        infos = self.tool.getattrs(self.tool, "resources", "info")
        align_id, blank_id, empty_id, using_id = [
            "".join(self.tool.build_identifier(
                self.tool.vars["values"][key],
                self.tool.vars["delims"]
            ).values())\
            for key in ["align", "blank", "empty", "using"]
        ]
        lengths = [len(info[:info.find(align_id)]) for info in infos
            if info is not None and info.find(align_id) != -1]
        max_length, spaces, i = max(lengths), 1, 0
        for info in infos:
            if info.find(align_id) != -1:
                print(info.replace(align_id, " " * (max_length - lengths[i] + spaces)))
                i += 1
            elif info.find(blank_id) != -1:
                print()
            elif info.find(empty_id) != -1:
                pass
            elif info.find(using_id) != -1:
                if pars and isinstance(pars[0], dict) and "using" in pars[0]:
                    using = pars[0]["using"]
                else:
                    using = self.tool.get_using()
                print(info.replace(using_id, using))
            elif info is not None:
                print(info)

    def set_call_cap(self, call, poss=1):
        """Sets in state a maximum number of uses for a resource instance call."""
        caps = self.state["caps"]
        caps.append({
            "name": call.__name__, "poss": poss, "used": 0
        })
        self.update_state({"caps": caps})

    def request_call(self, call):
        """Returns true if a function can be called, adding a use if capped."""
        for entry in self.state["caps"]:
            if entry["name"] == call and entry["used"] < entry["poss"]:
                entry["used"] += 1
            elif entry["name"] == call and entry["used"] >= entry["poss"]:
                return False
        return True

    def match_flag(self, flag):
        """Returns the option instance matching a flag, else a new to show help."""
        for resource in self.resources:
            if (hasattr(resource, "word") and flag == resource.word)\
                or (hasattr(resource, "char") and flag == resource.char):
                if (resource.call is not None and self.request_call(resource.call.__name__))\
                    or resource.items:
                    return resource
                else:
                    return Option({ "tool": self, "call": lambda self, pars: {} })
        else:
            print(f"Note: '{'--' if len(flag) > 1 else '-'}{flag}' is not a flag.")
            return Option({
                "tool": self,
                "call": self.show_help if self.request_call("show_help")\
                    else lambda self, pars: {}
            })

    def record_pooled(self, options):
        """Records pools to which option instances belong, each with an instance count."""
        for option in options:
            if hasattr(option.process, "pool") and option.process.pool in self.pools:
                self.pools[option.process.pool] += 1
            elif hasattr(option.process, "pool"):
                self.pools[option.process.pool] = 1

    def queue_options(self, strings):
        """Returns a task instance per flag with any arguments, then calls to record pools."""
        options = []
        for string in strings:
            if string[0] ==  "-" and string[1] != "-":
                for char in string[1:]:
                    options.append(self.Task({
                        "process": self.match_flag(char),
                        "args": []
                    }))
            elif string[0] == "-" and string[1] == "-":
                options.append(self.Task({
                    "process": self.match_flag(string[2:]),
                    "args": []
                }))
            elif options:
                options[-1].args.append(string)
        self.record_pooled(options)
        return options

    def queue_processes(self):
        """Returns a task for each process unpooled or pooled with 1+ options."""
        return [
            self.Task({"process": resource}) for resource in self.resources
            if isinstance(resource, Process) and not isinstance(resource, Option)
                and (not hasattr(resource, "pool") or (hasattr(resource, "pool")
                and resource.pool in self.pools and self.pools[resource.pool] > 0))
        ]

    def order_pools(self, tasks):
        """Returns all tasks with lead pools prioritised in lead attribute order."""
        for entry in self.lead[::-1]:
            for task in tasks:
                if hasattr(task.process, "pool") and task.process.pool == entry:
                    tasks.remove(task)
                    tasks.insert(0, task)
        return tasks

    def order_tasks(self, tasks):
        """Returns all tasks with the tasks in each pool in ascending rank order."""
        for pool in self.pools:
            i = 0
            indices = [tasks.index(task) for task in tasks if task.process.pool == pool]
            pooled_tasks = list(filter(lambda task: task.process.pool == pool, tasks))
            pooled_tasks.sort(key=lambda task: task.process.rank)
            for index in indices:
                tasks.pop(index)
                tasks.insert(index, pooled_tasks[i])
                i += 1
        return tasks

    def do_work(self, type):
        """Calls each function listed for the given type in the work attribute."""
        if self.work[type]:
            for call in self.work[type]:
                call()

    def run_tasks(self, pars):
        """Prepares tasks, then for each makes any call, else queues any items."""
        unordered_tasks = self.queue_options(pars) + self.queue_processes()
        self.tasks = self.order_tasks(self.order_pools(unordered_tasks))
        if self.tasks:
            print("Running tasks...")
        for task in self.tasks:
            if task.process.call is not None:
                new_state = task.process.call(task.process, task.args) or {}
            elif task.process.items:
                new_state = self.queue_items(self.state["root"],
                    task.process.items) or {}
            if "new_state" in dir() and new_state.keys():
                self.update_state(new_state)

    def use(self, pars):
        """Calls to perform any prep, then each major stage, then any tidying."""
        self.do_work("prep")
        self.run_tasks(pars)
        self.compose_items()
        self.build_batches()
        self.do_work("tidy")


class Sprker(Runner):

    def __init__(self, pars):
        super(Sprker, self).__init__(pars)

    @staticmethod
    def switch(self, pars=[]):
        """Prints all items in the TOOLS dictionary or replaces the active tool."""
        old = self.tool.get_using()
        if not pars:
            print(f"Active tool: {old}. Available: {'; '.join(TOOLS.keys())}.")
            return {}
        new = pars[0]
        if new not in TOOLS.keys():
            print(f"Tool '{new}' does not exist.")
            return {}
        content = self.tool.read_file(PATH_TO_SELF)
        content = content.replace(f'ACTIVE_TOOL = TOOLS["{old}"]', f'ACTIVE_TOOL = TOOLS["{new}"]')
        messages = {
            "success": f"Switched from {old} to {new}.",
            "failure": f"May not have switched from {old} to {new}."
        }
        self.tool.write_file(PATH_TO_SELF, content, "w", messages)
        self.tool.show_help(Option({"tool": TOOLS[new]}), [{"using": new}])

    @staticmethod
    def update(self, pars=[]):
        """Attempts to copy a sprkfile over the sprk source file."""
        src = PATH_TO_SPRKFILE
        if pars and os.path.isfile(pars[0])\
            and os.path.basename(pars[0]) == SPRKFILENAME:
            src = pars[0]
        elif pars and os.path.isdir(pars[0])\
            and SPRKFILENAME in os.listdir(pars[0]):
            src = Path(pars[0]) / SPRKFILENAME
        elif pars:
            print(f"Note: '{SPRKFILENAME}' not found at {pars[0]}.")
            return {}
        try:
            shutil.copy(src, PATH_TO_SELF)
            print("Updated sprk.")
        except Exception as err:
            print(f"May not have updated sprk.")
            print(err)

    @staticmethod
    def backup(self, pars=[]):
        """Attempts to copy the sprk source file to another location."""
        dest = PATH_TO_SPRKFILE
        if pars and os.path.basename(pars[0]) == SPRKFILENAME:
            dest = pars[0]
        elif pars and os.path.isdir(pars[0]):
            dest = Path(pars[0]) / SPRKFILENAME
        elif pars:
            print(f"{SPRKFILENAME} not copied: {pars[0]} not a valid argument for DIR.")
            return {}
        try:
            shutil.copy(PATH_TO_SELF, dest)
            print(f"Copied sprk to {dest}")
        except Exception as err:
            print(f"May not have copied sprk to {dest}")
            print(err)


# resource instances

BLANK = Resource({"info": "{BLANK}"})
USAGE = Resource({"info": "Usage: sprk [--option/-o [ARG ...] ...]"})
USING = Resource({"info": "Using: {USING}"})

SWITCH = {
    "desc": f"switch to TOOL or show tools currently available",
    "word": "switch",
    "char": "S",
    "call": Sprker.switch,
    "args": ["[TOOL]"]
}
BACKUP = {
    "desc": f"save sprk as/over a {SPRKFILENAME} here or in any DIR",
    "word": "backup",
    "char": "B",
    "call": Sprker.backup,
    "args": ["[DIR]"]
}
UPDATE = {
    "desc": f"replace sprk from a {SPRKFILENAME} here or in any DIR",
    "word": "update",
    "char": "U",
    "call": Sprker.update,
    "args": ["[DIR]"]
}
HELP = {
    "desc": "show the help page",
    "word": "help",
    "char": "h",
    "call": Runner.show_help
}


# TOOL: 'combined'

import webbrowser


# 'combined' template functions, receiving template instance as 'self'

def create_ignores(self):
    """Prepares each file in the ignores template and calls to queue all as a batch."""
    items = []
    for file in self.form["files"]:
        entries = []
        for type in list(filter(
            lambda key: key != "files" and key != "calls",
            self.form.keys()
        )):
            if type in file["list"]:
                entries.extend(self.form[type])
        items.append({
            "filename": file["name"],
            "content": "\n".join(self.tool.dedupe_list(entries))
        })
    self.tool.queue_items(self.tool.state["root"], items)


# 'combined' resource constants,
# e.g. strings & lists of dictionaries for resource 'items' attribute

ROOT_ITEMS = {

    "readme": [
        {
            "filename": "README.md",
            "content": "# {STATE:name}"
        }
    ],
    "license": [
        {
            "filename": "LICENSE.txt"
        }
    ]
}


# 'combined' resource functions,
# receiving resource instance as 'self' & any arguments as 'pars',
# optionally returning a dictionary with any state changes

def start_project(self, pars=[]):
    """Attempts to create a project folder and updates name and paths in state."""
    name = pars[0] if pars else self.tool.state["name"]
    path = CURRENT_DIR / name
    if path in CURRENT_DIR.iterdir():
        response = input(
            f"Folder '{name}' already exists. By continuing, files in the "
            f"existing '{name}' may be overwritten or otherwise modified.\n"
            "Continue? (enter 'y'/'Y' to continue; anything else to stop) "
        )
        if response not in ["y", "Y"]:
            sys.exit()
    root = code = path
    self.tool.create_folder(dirname=name)
    if self.tool.state["code"] != self.tool.state["root"]:
        code = self.tool.state["code"]
    return {"name": name, "root": root, "code": code}

def initialize_git(self, pars=[]):
    """Attempts to initialize a Git repo and updates the ignores template."""
    try:
        os.system(f'cd {self.tool.state["root"]}; git init; cd ..')
    except Exception as err:
        print("Git repository may not have been initialized.")
        print(err)
    self.tool.modify_template("ignores", {
        "nonr": [".git", ".gitignore"],
        "files": [
            {"name": ".gitignore", "list": ["rein", "sens"]}
        ]
    })

def open_browser_tab(url):
    webbrowser.open_new_tab(url)


# 'combined' template instances

IGNORES = {
    "name": "ignores",
    "core": ["files"],
    "form": {
        "rein": [],  # item type, reinstalled (str)
        "nonr": [],  # item type, non-runtime (str)
        "sens": [],  # item type, sensitive (str)
        "files": [],  # {"name": filename, "list": [type]}
        "calls": [create_ignores]
    }
}


# 'combined' resource instances

FOLDER = {
    "pool": "project",
    "rank": 1,
    "desc": "create a project folder here, with NAME if given",
    "word": "folder",
    "char": "f",
    "call": start_project,
    "args": ["[NAME]"]
}

GITINIT = {
    "pool": "project",
    "rank": 2,
    "desc": "initialize a Git repo & create a .gitignore file",
    "word": "gitinit",
    "char": "g",
    "call": initialize_git
}
README = {
    "desc": "create a README.md file w/ any NAME as its title",
    "word": "readme",
    "char": "r",
    "items": ROOT_ITEMS["readme"]
}
LICENSE = {
    "desc": "create a blank LICENSE.txt file (cf. '--choose')",
    "word": "license",
    "char": "l",
    "items": ROOT_ITEMS["license"]
}

CHOOSE = {
    "desc": "open the 'choosealicense.com' list in a new tab",
    "word": "choose",
    "char": "c",
    "call": lambda self, pars=[]: open_browser_tab("https://choosealicense.com/licenses")
}

SPRK = {
    "desc": "open the sprk Github repo page in a browser tab",
    "word": "sprk",
    "char": "s",
    "call": lambda self, pars=[]: open_browser_tab("https://github.com/barcek/sprk")
}
PYTHON = {
    "desc": "open the Python3 documentation in a browser tab",
    "word": "python",
    "char": "p",
    "call": lambda self, pars=[]: open_browser_tab("https://www.python.org/doc/")
}


# 'combined' tool class instantiation, passing configuration dictionary,
# with assignment of instance to key in TOOLS dictionary

TOOLS.update({
    "combined": Sprker({
        "prep": [lambda: print("Starting...")],
        "lead": ["project"],  # order of priority for any pools
        "tidy": [lambda: print("Finished.")]
    })
})


# 'combined' instance extension, passing template & resource class instantiations

TOOLS["combined"].insert_templates([

    Template(IGNORES)
])

TOOLS["combined"].provide_resources([

    BLANK,
    USAGE,

    BLANK,
    Resource({"info": "Apply any or all of the following options for the action(s) described."}),
    BLANK,

    Option(FOLDER),

    BLANK,
    Resource({"info": "and then inside this folder, or here if not created, do the following:"}),
    BLANK,

    Option(GITINIT),

    BLANK,

    Option(README),
    Option(LICENSE),

    BLANK,
    Resource({"info": "and/or do the following:"}),
    BLANK,

    Option(CHOOSE),

    BLANK,

    Option(BACKUP),
    Option(UPDATE),

    BLANK,

    Option(SPRK),
    Option(PYTHON),

    BLANK,

    Option(SWITCH),

    BLANK,

    Option(HELP),

    BLANK,
    Resource({"info": f"and customize the tool: add, modify or remove any option via {SPRKFILENAME}."}),
    BLANK,

    USING,
    BLANK
])


# TOOL: 'creator'

# 'creator' tool class instantiation, passing configuration dictionary,
# & assignment of new instance to own key in TOOLS dictionary

TOOLS.update({
    "creator": Sprker({
        "prep": [lambda: print("Starting...")],
        "lead": ["project"],  # order of priority for any pools
        "tidy": [lambda: print("Finished.")]
    })
})

# 'creator' instance extension, passing template & resource class instantiations

TOOLS["creator"].insert_templates([

    Template(IGNORES)
])

TOOLS["creator"].provide_resources([

    BLANK,
    USAGE,

    BLANK,
    Resource({"info": "Apply any or all of the following options for the action(s) described."}),
    BLANK,

    Option(FOLDER),

    BLANK,
    Resource({"info": "and then inside this folder, or here if not created, do the following:"}),
    BLANK,

    Option(GITINIT),

    BLANK,

    Option(README),
    Option(LICENSE),

    BLANK,
    Resource({"info": "and/or do the following:"}),
    BLANK,

    Option(CHOOSE),

    BLANK,

    Option(BACKUP),
    Option(UPDATE),

    BLANK,

    Option(SWITCH),

    BLANK,

    Option(HELP),

    BLANK,
    Resource({"info": f"and customize the tool: add, modify or remove any option via {SPRKFILENAME}."}),
    BLANK,

    USING,
    BLANK
])


# TOOL: 'adapter'

# 'adapter' tool class instantiation, passing configuration dictionary,
# & assignment of new instance to own key in TOOLS dictionary

TOOLS.update({
    "adapter": Sprker({
        "prep": [lambda: print("Starting...")],
        "tidy": [lambda: print("Finished.")]
    })
})


# 'adapter' instance extension, passing template & resource class instantiations

TOOLS["adapter"].provide_resources([

    BLANK,
    USAGE,

    BLANK,
    Resource({"info": "Apply any or all of the following options for the action(s) described."}),
    BLANK,

    Option(SPRK),
    Option(PYTHON),

    BLANK,

    Option(BACKUP),
    Option(UPDATE),

    BLANK,

    Option(SWITCH),

    BLANK,

    Option(HELP),

    BLANK,
    Resource({"info": f"and customize the tool: add, modify or remove any option via {SPRKFILENAME}."}),
    BLANK,

    USING,
    BLANK
])


# declaration & assignment for ACTIVE_TOOL constant

ACTIVE_TOOL = TOOLS["combined"]

# use of ACTIVE_TOOL, passing any relevant arguments

if len(sys.argv) > 1:
    ACTIVE_TOOL.use(sys.argv)
elif "show_help" in dir(Runner):
    Runner.show_help(Resource({
        "tool": ACTIVE_TOOL
    }), None)
